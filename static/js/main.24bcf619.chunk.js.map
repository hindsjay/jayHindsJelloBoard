{"version":3,"sources":["components/Welcome.js","components/Header.js","components/Form.js","utils/firebase.js","components/Task.js","components/Edit.js","components/Main.js","components/App.js","serviceWorker.js","index.js"],"names":["Welcome","props","className","type","onClick","enterButtonClicked","Header","Form","htmlFor","id","placeholder","onChange","event","inputVal","value","userInputState","handleClick","firebase","initializeApp","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","Task","taskValue","editTask","removeTask","Edit","defaultValue","editingInput","editHandleChange","saveTask","Main","handleChange","setState","userInput","target","preventDefault","state","database","ref","push","alert","task","child","remove","taskKey","inputValue","tasks","forEach","taskItem","key","editing","updatedTasksState","editingKey","set","on","response","newState","data","val","this","map","Component","App","toggleEnteredState","notEntered","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.24bcf619.chunk.js","sourcesContent":["import React from 'react';\n\n// stateless component\nconst Welcome = (props) => {\n  return (\n    <header className=\"welcomeHeaderContainer\">\n      <div className=\"welcomeContentContainer\">\n        <h1 className=\"welcomeHeader\">Jello</h1>\n\n        <p>Welcome to Jello!</p>\n        <p>A Trello like task board to keep you organized and focused on the most important tasks</p>\n\n        <button type=\"button\" onClick={ () => {props.enterButtonClicked()} }>Enter</button>\n      </div>\n    </header>\n  )\n}\n\nexport default Welcome;","import React from 'react';\n\n// stateless component\nconst Header = () => {\n  return (\n    <header className=\"mainAppHeader\">\n      <h1>Jello</h1>\n    </header>\n  )\n}\n\nexport default Header;","import React from 'react';\n\n// stateless component\nconst Form = (props) => {\n  return (\n    <form className=\"mainForm\">\n      <label htmlFor=\"taskInput\" className=\"srOnly\"></label>\n      <input \n        type=\"text\" \n        id=\"taskInput\" \n        className=\"taskInput\" \n        placeholder=\"Input Task Here...\"\n        onChange={ (event) => {props.inputVal(event)} }\n        value={props.userInputState}\n      >\n      </input>\n      <button type=\"submit\" onClick={ (event) => {props.handleClick(event)} }>Add Task</button>\n    </form>\n  )\n};\n\nexport default Form;","import firebase from 'firebase';\n\n// Firebase configuration\nconst firebaseConfig = {\n  apiKey: \"AIzaSyDvmCIhenNay49FjRf5eq0z08sTop651uQ\",\n  authDomain: \"jello-database.firebaseapp.com\",\n  databaseURL: \"https://jello-database.firebaseio.com\",\n  projectId: \"jello-database\",\n  storageBucket: \"jello-database.appspot.com\",\n  messagingSenderId: \"954320055794\",\n  appId: \"1:954320055794:web:006031744c1a0e4957cf6b\"\n};\n\n// Initialize Firebase\nfirebase.initializeApp(firebaseConfig);\n\nexport default firebase;","import React, { Fragment } from 'react';\n\n// stateless component\nconst Task = (props) => {\n  return (\n    <Fragment>\n      <p>{props.taskValue}</p> \n      <div className=\"editDeleteContainer\">\n        <button type=\"button\" onClick={props.editTask}>edit</button>\n        <button type=\"button\" onClick={props.removeTask}>delete</button>\n      </div>\n    </Fragment>\n  )\n}\n\nexport default Task;","import React, { Fragment } from 'react';\n\nconst Edit = (props) => {\n  return (\n    <Fragment>\n      <form>\n        <input \n          defaultValue={props.editingInput}\n          onChange={props.editHandleChange}\n        >\n        </input>\n        <button className=\"saveButton editModeButton\" type=\"submit\" onClick={props.saveTask}>Save</button>\n      </form>\n    </Fragment>\n  )\n}\n\nexport default Edit;","import React, { Component } from 'react';\nimport Form from './Form.js';\nimport firebase from '../utils/firebase.js';\nimport Task from './Task.js';\nimport Edit from './Edit.js';\n\n\nclass Main extends Component {\n  constructor() {\n    super()\n\n    this.state = {\n      tasks: [],\n      userInput: '',\n      editingInput: '',\n    }\n  }\n\n\n  // componentDidMount lifecycle method which executes once component mounts\n  // this allows us to sync the items in our database to our app (and therefore our UI) - items in our database will show up in our UI\n  componentDidMount() {\n    const dbRef = firebase.database().ref();\n\n    // event listener that fires anytime there is a change in the database\n    dbRef.on('value', (response) => {\n      const newState = [];\n      const data = response.val();\n\n      // for in loop to access each task item in our data object and push each task item to our new state array\n      for (let key in data) {\n        newState.push({key: key, value: data[key], editing: false});\n      }\n\n      // execute setState to initiate re-render which will update our page with task items in database (current and new ones (if there are any new ones) )\n      this.setState({\n        tasks: newState,\n      })\n    });\n  }\n\n\n  // fires each time a user inputs a value into main input when adding a task\n  // used to keep track of the values entered\n  handleChange = (event) => {\n    this.setState({\n      userInput: event.target.value,\n    })\n  }\n\n  // fires each time a user inputs a value into the input field when editing a task\n  // like above used to keep track of values entered\n  editHandleChange = (event) => {\n    this.setState({\n      editingInput: event.target.value,\n    })\n  }\n\n\n  // when the add task button is clicked this will add item to the database and also update the screen due to the .on method we have that fires each time the database is changed\n  handleClick = (event) => {\n    // prevent default action on form submission\n    event.preventDefault();\n\n    // error handling if input field is blank\n    if (this.state.userInput) {\n      // reference to database\n      const dbRef = firebase.database().ref();\n      // whatever value is in state for userInput on submission/button click, we want to add this to our database\n      dbRef.push(this.state.userInput);\n      // reset state of input so it's blank\n      this.setState({\n        userInput: '',\n      })\n    } else {\n      alert(`input cannot be left blank - please enter a task`);\n    }\n  }\n\n\n  // function to remove item\n  removeTask = (task) => {\n    // reference our database\n    const dbRef = firebase.database().ref();\n    // remove the task item of choice from database, which also results in the screen being updated due to the .on() method we initialized in the componentDidMount method\n    dbRef.child(task).remove();\n  }\n\n\n  // function to edit task item - fires when edit button is clicked\n  editTask = (taskKey) => {\n    let inputValue;\n    this.state.tasks.forEach((taskItem) => {\n      if (taskItem.key === taskKey) {\n        taskItem.editing = !taskItem.editing;\n        inputValue = taskItem.value;\n      }\n    });\n\n    // make copy of our tasks located in state to be used when updating state in setState\n    const updatedTasksState = [...this.state.tasks];\n\n    this.setState({\n      tasks: updatedTasksState,\n      editingInput: inputValue,\n    })\n  }\n\n\n  // save task function - fires when save button is clicked in \"editing\" mode\n  saveTask = () => {\n    let editingKey;\n\n    // loop through each item in tasks array located in state\n    this.state.tasks.forEach((task) => {\n      if (task.editing) {\n        task.editing = !task.editing;\n        task.value = this.state.editingInput;\n        editingKey = task.key;\n      }\n    });\n\n    // make copy of our tasks located in state to be used when updating state in setState\n    const updatedTasksState = [...this.state.tasks];\n    // reference to our database but reference to the specific task item we want to update the value of\n    const dbRef = firebase.database().ref(editingKey);\n    // updating the task value in our database to the value that's in our editingInput state\n    dbRef.set(this.state.editingInput);\n    // update state and initiate re-render\n    this.setState({\n      tasks: updatedTasksState,\n      editingInput: '',\n    })\n  } \n\n\n  render() {\n    return(\n      <main>\n        <div className=\"wrapper\">\n          <div className=\"scrollWrapper\">\n            <section className=\"cardContainer\">\n              <h2>Task List</h2>\n              <div className=\"taskItemContainer\">\n              {\n                this.state.tasks.map((task) => {\n                  return (\n                    <div key={task.key} className=\"taskItem\">\n                    { task.editing === false ? \n                      <Task \n                        taskValue={task.value}\n                        editTask={ () => {this.editTask(task.key)} }\n                        removeTask={ () => {this.removeTask(task.key)} }\n                      />\n                      :\n                      <Edit\n                        editingInput={this.state.editingInput}\n                        editHandleChange={this.editHandleChange}\n                        saveTask={this.saveTask}\n                      />\n                    }\n                    </div>\n                  )\n                })\n              }\n              </div>\n            </section>\n\n            {/* One of my stretch goals was to include the functionality to move each task to a different column - I decided to stick to the MVP for this project and will work on this feature afterwards */}\n            <section className=\"cardContainer\">\n              <h2>In Progress</h2>\n            </section>\n\n            <section className=\"cardContainer\">\n              <h2>Done</h2>\n            </section>\n          </div>\n        </div>\n\n        <Form \n          inputVal={this.handleChange} \n          userInputState={this.state.userInput} \n          handleClick={this.handleClick}\n        />\n      </main>\n    )\n  }\n}\n\nexport default Main;","import React, { Component, Fragment } from 'react';\nimport Welcome from './Welcome.js';\nimport Header from './Header.js';\nimport Main from './Main.js';\n\n\nclass App extends Component {\n  constructor() {\n    super()\n\n    this.state = {\n      notEntered: true,\n    }\n  }\n\n\n  toggleEnteredState = () => {\n    this.setState({\n      notEntered: !this.state.notEntered\n    })\n  }\n\n\n  render() {\n    return (\n      <div className=\"App\">\n        {\n          this.state.notEntered \n            ? <Welcome enterButtonClicked={this.toggleEnteredState} /> \n            : <Fragment>\n                <Header />\n                <Main />\n              </Fragment>\n        }\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App.js';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}